#define CPU_ENC 3
#define CPU_DEC 2
#define CPU_DEC_1 1
/*
 * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
 * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
 * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
 */

/* $Header: /tmp_amd/presto/export/kbs/jutta/src/gsm/RCS/toast.c,v 1.8 1996/07/02 10:41:04 jutta Exp $ */

#include	"toast.h"
#include 	"my_private.h"
#include        "marcus_dec_mem.h"
/*  toast -- lossy sound compression using the gsm library.
 */
#ifdef SASA_MPARM
#include "sasa_misc.h"
#include "sasa_support.h"
#include "sasa_profile.h"
#endif

#ifdef SASA_MPARM
#include "appsupport.h"
#ifdef OLD_MPARM
int irq_counter=0;
void interrupt_function() __attribute__((interrupt));
void interrupt_function()
{
  *((int*)0x90050000) &= ~0x800000;                       /* Compulsory in an interrupt routine */
  PR(NODE_NUMBER, 8, -1);                                 /* Inside interrupt routine */
  irq_counter++;
}
#endif
#endif

char   * progname;

int	f_decode   = 1;		/* decode rather than encode	 (-d) */
int 	f_cat	   = 0;		/* write to stdout; implies -p   (-c) */
int	f_force	   = 0;		/* don't ask about replacements  (-f) */
int	f_precious = 0;		/* avoid deletion of original	 (-p) */
int	f_fast	   = 0;		/* use faster fpt algorithm	 (-F) */
int	f_verbose  = 0;		/* debugging			 (-V) */
int	f_ltp_cut  = 0;		/* LTP cut-off margin	      	 (-C) */
int sasa_malloc_counter=0;
struct stat instat;		/* stat (inname) 		 */

FILE	*in, 	 *out;
char	*inname, *outname;

/*
 *  The function (*output)() writes a frame of 160 samples given as
 *  160 signed 16 bit values (gsm_signals) to <out>.
 *  The function (*input)() reads one such frame from <in>.
 *  The function (*init_output)() begins output (e.g. writes a header).,
 *  The function (*init_input)() begins input (e.g. skips a header).
 *
 *  There are different versions of input, output, init_input and init_output
 *  for different formats understood by toast; which ones are used 
 *  depends on the command line arguments and, in their absence, the
 *  filename; the fallback is #defined in toast.h
 *
 *  The specific implementations of input, output, init_input and init_output
 *  for a format `foo' live in toast_foo.c.
 */

int	(*output   ) P((gsm_signal *)),
	(*input    ) P((gsm_signal *));
int	(*init_input)  P((void)),
	(*init_output) P((void));

static int	generic_init P0() { return 0; }	/* NOP */

struct fmtdesc {

	char * name, * longname, * suffix;

	int  (* init_input )  P((void)),
	     (* init_output)  P((void));

	int  (* input ) P((gsm_signal * )),
	     (* output) P((gsm_signal * ));

} f_audio = {
		"audio",
		"8 kHz, 8 bit u-law encoding with Sun audio header", ".au",
		audio_init_input,
		audio_init_output,
		ulaw_input,
		ulaw_output
}, f_ulaw = {
		"u-law", "plain 8 kHz, 8 bit u-law encoding", ".u",
		generic_init,
		generic_init,
		ulaw_input,
		ulaw_output 

}, f_alaw = {
		"A-law", "8 kHz, 8 bit A-law encoding", ".A",
		generic_init,
		generic_init,
		alaw_input,
		alaw_output

}, f_linear = {
		"linear",
		"16 bit (13 significant) signed 8 kHz signal", ".l",
		generic_init,
		generic_init,
		linear_input,
		linear_output
};

struct fmtdesc * alldescs[] = {
	&f_audio,
	&f_alaw,
	&f_ulaw,
	&f_linear,
	(struct fmtdesc *)NULL
};

#define	DEFAULT_FORMAT	f_ulaw		/* default audio format, others	*/
					/* are: f_alaw,f_audio,f_linear */
struct fmtdesc * f_format  = 0;

/*
 *  basename + suffix of a pathname
 */
static char * endname P1((name), char * name)
{
	if (name) {
		char * s = strrchr(name, '/');
		if (s && s[1]) name = s + 1;
	}
	return name;

}

/*
 *  Try to figure out what we're supposed to do from the argv[0], if
 *  any, and set the parameters accordingly.
 */
static void parse_argv0 P1((av0), char * av0 )
{
	int 	l;

	progname = av0 = endname(av0 ? av0 : "toast");

	/*  If the name starts with `un', we want to decode, not code.
	 *  If the name ends in `cat', we want to write to stdout,
	 *  and decode as well.
	 */

	if (!strncmp(av0, "un", 2)) f_decode = 1;
	if (  (l = strlen(av0)) >= 3 /* strlen("cat") */
	   && !strcmp( av0 + l - 3, "cat" )) f_cat = f_decode = 1;
}


/*
 *  Check whether the name (possibly generated by appending
 *  .gsm to something else) is short enough for this system.
 */
static int length_okay P1((name), char * name)
{
	long	max_filename_length = 0;
	char	* end;

	/* If our _pathname_ is too long, we'll usually not be
	 * able to open the file at all -- don't worry about that.
	 * 
	 * But if the _filename_ is too long, there is danger of
	 * silent truncation on some systems, which results
	 * in the target replacing the source!
	 */

	if (!name) return 0;
	end = endname(name);

#ifdef	NAME_MAX
	max_filename_length  = NAME_MAX;
#else
#ifdef	_PC_NAME_MAX
#ifdef USE_PATHCONF
	{	char * s, tmp; 
		
		/*  s = dirname(name)
		 */
		if ((s = end) > name) {
			if (s > name + 1) s--;
			tmp = s;
			*s  = 0;
		}

		errno = 0;
		max_filename_length = pathconf(s > name ? name : ".",
			_PC_NAME_MAX);
		if (max_filename_length == -1 && errno) {
			perror( s > name ? name : "." );
			fprintf(stderr,
		"%s: cannot get dynamic filename length limit for %s.\n",
				progname, s > name ? name : ".");
			return 0;
		}
		if (s > name) *s = tmp;
	}
#endif /* USE_PATHCONF  */
#endif /* _PC_NAME_MAX  */
#endif /* !NAME_MAX 	*/

	if (max_filename_length > 0 && strlen(end) > max_filename_length) {
		fprintf(stderr,
			"%s: filename \"%s\" is too long (maximum is %ld)\n",
			progname, endname(name), max_filename_length );
		return 0;
	}

	return 1;
}

/*
 *  Return a pointer the suffix of a string, if any.
 *  A suffix alone has no suffix, an empty suffix can not be had.
 */
static char * suffix P2((name, suf), char *name, char * suf) 
{
	size_t nlen = strlen(name);
	size_t slen = strlen(suf);

	if (!slen || nlen <= slen) return (char *)0;
	name += nlen - slen;
	return memcmp(name, suf, slen) ? (char *)0 : name;
}


static void catch_signals P1((fun), SIGHANDLER_T (*fun) ()) 
{
#ifndef SASA_COMMENT

#ifdef	SIGHUP
	signal( SIGHUP,   fun );
#endif
#ifdef	SIGINT
	signal( SIGINT,   fun );
#endif
#ifdef	SIGPIPE
	signal( SIGPIPE,  fun );
#endif
#ifdef	SIGTERM
	signal( SIGTERM,  fun );
#endif
#ifdef	SIGXFSZ
	signal( SIGXFSZ,  fun );
#endif

#endif /*SASA_COMMENT*/
}

static SIGHANDLER_T onintr P0()
{
#ifndef SASA_COMMENT
	char * tmp = outname;

#ifdef	HAS_SYSV_SIGNALS
	catch_signals( SIG_IGN );
#endif

	outname = (char *)0;
#ifndef SASA
	if (tmp) (void)unlink(tmp);
#endif /*SASA*/
#endif
	exit(1);
}

/*
 *  Allocate some memory and complain if it fails.
 */
static char * emalloc P1((len), size_t len)
{
	char * s;
	if (!(s = malloc(len))) {
#ifndef SASA_COMMENT
		fprintf(stderr, "%s: failed to malloc %d bytes -- abort\n",
			progname, len);
		onintr();
#endif
		exit(1);
	}
	return s;
}

static char* normalname P3((name, want, cut), char *name, char *want,char *cut)
{
	size_t	maxlen;
	char 	* s, * p;

	p = (char *)0;
	if (!name) return p;

	maxlen = strlen(name) + 1 + strlen(want) + strlen(cut);
	p = strcpy(emalloc(maxlen), name);

	if (s = suffix(p, cut)) strcpy(s, want);
	else if (*want && !suffix(p, want)) strcat(p, want);

	return p;
}

/*
 *  Generate a `plain' (non-encoded) name from a given name.
 */
static char * plainname P1((name), char *name)
{
	return normalname(name, "", SUFFIX_TOASTED );
}

/*
 *  Generate a `code' name from a given name.
 */
static char * codename P1((name), char *name)
{
	return normalname( name, SUFFIX_TOASTED, "" );
}

/*
 *  If we're supposed to ask (fileno (stderr) is a tty, and f_force not
 *  set), ask the user whether to overwrite a file or not.
 */
static int ok_to_replace P1(( name ), char * name)
{
	int reply, c;

	if (f_force) return 1;			/* YES, do replace   */
	if (!isatty(fileno(stderr))) return 0;	/* NO, don't replace */

	fprintf(stderr,
		"%s already exists; do you wish to overwrite %s (y or n)? ",
		name, name);
	fflush(stderr);

	for (c = reply = getchar(); c != '\n' && c != EOF; c = getchar()) ;
	if (reply == 'y') return 1;

	fprintf(stderr, "\tnot overwritten\n");
	return 0;
}

static void update_mode P0()
{
#ifndef SASA_COMMENT
	if (!instat.st_nlink) return;		/* couldn't stat in */


#ifdef HAS_FCHMOD
	if (fchmod(fileno(out), instat.st_mode & 07777)) {
		perror(outname);
		fprintf(stderr, "%s: could not change file mode of \"%s\"\n",
			progname, outname);
	}
#else 
#ifdef HAS_CHMOD
	if (outname && chmod(outname, instat.st_mode & 07777)) {
		perror(outname);
		fprintf(stderr, "%s: could not change file mode of \"%s\"\n",
			progname, outname);
	}
#endif /* HAS_CHMOD  */
#endif /* HAS_FCHMOD */

#endif /*SASA_COMMENT*/
}

static void update_own P0()
{
	if (!instat.st_nlink) return; /* couldn't stat in */
#ifdef HAS_FCHOWN
/*	(void)fchown(fileno(out), instat.st_uid, instat.st_gid);*/
#else 
#ifdef HAS_CHOWN
	(void)chown(outname, instat.st_uid, instat.st_gid);
#endif /* HAS_CHOWN  */
#endif /* HAS_FCHOWN */
}

static void update_times P0()
{
#ifndef SASA_COMMENT

	if (!instat.st_nlink) return; 	/* couldn't stat in */

#ifdef HAS_UTIMES
	if (outname) {
		struct timeval tv[2];

		tv[0].tv_sec  = instat.st_atime;
		tv[1].tv_sec  = instat.st_mtime;
		tv[0].tv_usec = tv[1].tv_usec = 0;
		(void) utimes(outname, tv);
	}
#else
#ifdef HAS_UTIME

	if (outname) {

#ifdef	HAS_UTIMBUF
		struct utimbuf ut;

		ut.actime     = instat.st_atime;
		ut.modtime    = instat.st_mtime;

#	ifdef	HAS_UTIMEUSEC
		ut.acusec     = instat.st_ausec;
		ut.modusec    = instat.st_musec;
#	endif 	/* HAS_UTIMEUSEC */

		(void) utime(outname, &ut);

#else /* UTIMBUF */

		time_t ut[2];

		ut[0] = instat.st_atime;
		ut[1] = instat.st_mtime;

		(void) utime(outname, ut);

#endif	/* UTIMBUF */
	}
#endif /* HAS_UTIME */
#endif /* HAS_UTIMES */

#endif /*SASA_COMMENT*/
}


static int okay_as_input P3((name,f,st), char* name, FILE* f, struct stat * st)
{
/*
# ifdef	HAS_FSTAT
	if (fstat(fileno(f), st) < 0)
# else
	if (stat(name, st) < 0)
# endif
	{
		perror(name);
		fprintf(stderr, "%s: cannot stat \"%s\"\n", progname, name);
		return 0;
	}

	if (!S_ISREG(st->st_mode)) {
		fprintf(stderr,
			"%s: \"%s\" is not a regular file -- unchanged.\n",
			progname, name);
		return 0;
	}
	if (st->st_nlink > 1 && !f_cat && !f_precious) {
		fprintf(stderr, 
		      "%s: \"%s\" has %s other link%s -- unchanged.\n",
			progname,name,st->st_nlink - 1,"s" + (st->st_nlink<=2));
		return 0;
	}
*/
	return 1;
}

static void prepare_io P1(( desc), struct fmtdesc * desc)
{
	output      = desc->output;
	input       = desc->input;

	init_input  = desc->init_input;
	init_output = desc->init_output;
}

static struct fmtdesc * grok_format P1((name), char * name)
{
	char * c;
	struct fmtdesc ** f;

	if (name) {
		c = plainname(name);

		for (f = alldescs; *f; f++) {
			if (  (*f)->suffix
			   && *(*f)->suffix
			   && suffix(c, (*f)->suffix)) {

				free(c);
				return *f;
			}
		}

		free(c);
	}
	return (struct fmtdesc *)0;
}

static int open_input P2((name, st), char * name, struct stat * st)
{
	struct fmtdesc * f = f_format;
	st->st_nlink = 0;	/* indicates `undefined' value */
	
	if (!name) {
		inname = (char *)NULL;
		in     = stdin;
#ifdef	HAS__FSETMODE
		_fsetmode(in, "b");
#endif
	}
	else {
		if (f_decode) inname = codename(name);
		else {
			if (!f_cat && suffix(name, SUFFIX_TOASTED)) {
				fprintf(stderr,
			"%s: %s already has \"%s\" suffix -- unchanged.\n",
					progname, name, SUFFIX_TOASTED );
				return 0;
			}
			inname = strcpy(emalloc(strlen(name)+1), name);
		}
#ifndef SASA_COMMENT
		if (!(in = fopen(inname, READ))) {
			perror(inname);	/* not guaranteed to be valid here */
			fprintf(stderr, "%s: cannot open \"%s\" for reading\n",
				progname, inname);
			return 0;
		}
		if (!okay_as_input(inname, in, st)) return 0;
#endif/*SASA_COMMENT*/
		if (!f) f = grok_format(inname);
	}
	prepare_io( f ? f : & DEFAULT_FORMAT );
	
	return 1;
}

static int open_output P1((name), char *name)
{
	if (!name || f_cat) {
		out     = stdout;
		outname = (char *)NULL;
#ifdef	HAS__FSETMODE
		_fsetmode(out, "b"); 
#endif
	}
	else {
		int outfd = -1;
		char *o;
		o = (*(f_decode ? plainname : codename))(name);
/*		printf("SASA DEBUG: output file name: %s\n", o);*/
 		/*
		if (!length_okay(o)) return 0;
		if ((outfd = open("sasa\0", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU )) >= 0)
			out = fdopen(outfd, WRITE);
		else if (errno != EEXIST) out = (FILE *)NULL;
		else if (ok_to_replace(o)) out = fopen(o, WRITE);
		else return 0;
		*/
#ifndef SASA_COMMENT
                out = fopen(o, "w");
		if (!out) {
			perror(o);
			fprintf(stderr,
				"%s: can't open \"%s\" for writing\n",
				progname, o);
			if (outfd >= 0) (void)close(outfd);
			return 0;
		}
#endif /*SASA_COMMENT*/
		outname = o;
	}
	return 1;
}

gsm      	r;
gsm_signal    	*s;
gsm_byte	*d;
char		*sasa_barrier;
char            *marcus_barrier;
char		*sasa_sem;

gsm			en_r;
struct gsm_state	* en_s1_S;
word    		* en_s1_Nc;    /* [0..3] LTP lag                       OUT     */
word    		* en_s1_bc;    /* [0..3] coded LTP gain                OUT     */
word    		* en_s1_Mc;    /* [0..3] RPE grid selection            OUT     */
word    		* en_s1_xmaxc; /* [0..3] Coded maximum amplitude       OUT     */
word    		* en_s1_xMc;   /* [13*4] normalized RPE samples        OUT     */
word    		* en_s1_LARc;  /* [0..7] LAR coefficients              OUT     */
word    		* en_s1_e;     /*e[50]*/
word    		* en_s1_so;    /*s[160]*/


int* memory_map;
int items_memory_map;

extern volatile int *lock;


static void
store_from_locals(struct gsm_state *S, word* Nc, word* bc, word* Mc, word* xmaxc, 
		  word* xMc, word* LARc, word *e, word *so) {

  int i,j;
  MARCUS_DEBUG_MESSAGE(-8110)
  // wait until the memory for the next write becomes empty!
  WAIT(0);  
  MARCUS_DEBUG_MESSAGE(-8111)

  { 
    MARCUS_DEBUG_MESSAGE(-800)    
    for(i=0; i<4; i++) en_s1_Nc[i] = Nc[i];
    for(i=0; i<4; i++) en_s1_bc[i] = bc[i];
    for(i=0; i<4; i++) en_s1_Mc[i] = Mc[i];
    for(i=0; i<4; i++) en_s1_xmaxc[i] = xmaxc[i];
    for(i=0; i<13*4; i++) en_s1_xMc[i] = xMc[i];
    for(i=0; i<8; i++) en_s1_LARc[i] = LARc[i];
    for(i=0; i<50; i++) en_s1_e[i] = e[i];
    for(i=0; i<160; i++) en_s1_so[i] = so[i];
    MARCUS_DEBUG_MESSAGE(-801)
  }  
  lock[0]=1;
  SIGNAL(1);
}



static void
read_to_locals(struct gsm_state *S, word* Nc, word* bc, word* Mc, word* xmaxc, 
	       word* xMc, word* LARc, word *e, word *so) {  
  int i,j;
  MARCUS_DEBUG_MESSAGE(-9110)
  // wait until the memory for the next read becomes full!
  WAIT(1);
  MARCUS_DEBUG_MESSAGE(-9111)
  {
    MARCUS_DEBUG_MESSAGE(-900)    
    for(i=0; i<4; i++)  Nc[i] = en_s1_Nc[i];
    for(i=0; i<4; i++) bc[i] = en_s1_bc[i];
    for(i=0; i<4; i++)  Mc[i] = en_s1_Mc[i];
    for(i=0; i<4; i++) xmaxc[i] = en_s1_xmaxc[i];
    for(i=0; i<13*4; i++)  xMc[i] = en_s1_xMc[i];
    for(i=0; i<8; i++) LARc[i] = en_s1_LARc[i];
    for(i=0; i<50; i++)  e[i] = en_s1_e[i];
    for(i=0; i<160; i++) so[i] = en_s1_so[i];    
    MARCUS_DEBUG_MESSAGE(-901)
  }  
  lock[1]=1;
  SIGNAL(0); 
   
}

gsm		de_r;
struct gsm_state * de_s1_S;
word            * de_s1_LARcr;  /* [0..7]               IN      */
word            * de_s1_Ncr;    /* [0..3]               IN      */
word            * de_s1_bcr;    /* [0..3]               IN      */
word            * de_s1_Mcr;    /* [0..3]               IN      */
word            * de_s1_xmaxcr; /* [0..3]               IN      */
word            * de_s1_xMcr;   /* [0..13*4]            IN      */
word            * de_s1_s;         /* [0..159]          OUT     */
word            * de_s1_erp;       /*40*/
word            * de_s1_wt;        /*[160]*/
word            * de_s1_drp;
int             * de_s1_empty;


static void
dec_store_from_locals(struct gsm_state *S, word *LARcr, word *Ncr, word *bcr, word *Mcr,
                      word *xmaxcr, word *xMcr, word *s, word *erp, word *wt, word *drp) {

  int i,j;
  MARCUS_DEBUG_MESSAGE(-600)
  WAIT(2);
  /*
  for(i=0; i<280; i++) de_s1_S->dp0[i]=S->dp0[i];
  de_s1_S->z1 = S->z1;
  de_s1_S->L_z2 = S->L_z2;
  de_s1_S->mp = S->mp;
  for(i=0; i<8; i++) de_s1_S->u[i]=S->u[i];
  for(i=0; i<2; i++) for(j=0;j<8;j++) de_s1_S->LARpp[i][j]=S->LARpp[i][j];
  de_s1_S->j = S->j;
  de_s1_S->ltp_cut = S->ltp_cut;
  de_s1_S->nrp = S->nrp;
  for(i=0; i<9; i++) de_s1_S->v[i]=S->v[i];
  de_s1_S->msr = S->msr;
  de_s1_S->verbose = S->verbose;
  de_s1_S->fast = S->fast;
  de_s1_S->wav_fmt = S->wav_fmt;
  de_s1_S->frame_index = S->frame_index;
  de_s1_S->frame_chain = S->frame_chain;
  */
  for(i=0; i<8; i++) de_s1_LARcr[i] = LARcr[i];
  for(i=0; i<4; i++) de_s1_Ncr[i] = Ncr[i];
  for(i=0; i<4; i++) de_s1_bcr[i] = bcr[i];
  for(i=0; i<4; i++) de_s1_xmaxcr[i] = xmaxcr[i];
  for(i=0; i<13*4; i++) de_s1_xMcr[i] = xMcr[i];
  for(i=0; i<160; i++) de_s1_s[i] = s[i];
  for(i=0; i<40; i++) de_s1_erp[i] = erp[i];
  for(i=0; i<160; i++) de_s1_wt[i] = wt[i];
  de_s1_drp[0] = drp[0];
  lock[2]=1;
  SIGNAL(3);
  MARCUS_DEBUG_MESSAGE(-601)
}



static void
dec_read_to_locals(struct gsm_state *S, word *LARcr, word *Ncr, word *bcr, word *Mcr,
                   word *xmaxcr, word *xMcr, word *s, word *erp, word *wt, word *drp) {  

  int i,j;
  MARCUS_DEBUG_MESSAGE(-500)
  WAIT(3);
/*
  for(i=0; i<280; i++) S->dp0[i] = de_s1_S->dp0[i];
  S->z1 = de_s1_S->z1;
  S->L_z2=de_s1_S->L_z2;
  S->mp = de_s1_S->mp;
  for(i=0; i<8; i++) S->u[i] = de_s1_S->u[i];
  for(i=0; i<2; i++) for(j=0;j<8;j++) S->LARpp[i][j] = de_s1_S->LARpp[i][j];
  S->j = de_s1_S->j;
  S->ltp_cut = de_s1_S->ltp_cut;
  S->nrp= de_s1_S->nrp;
  for(i=0; i<9; i++) S->v[i] = de_s1_S->v[i];
  S->msr = de_s1_S->msr;
  S->verbose = de_s1_S->verbose;
  S->fast = de_s1_S->fast;
  S->wav_fmt = de_s1_S->wav_fmt;
  S->frame_index = de_s1_S->frame_index;
  S->frame_chain = de_s1_S->frame_chain;
*/
  for(i=0; i<8; i++) LARcr[i] = de_s1_LARcr[i];
  for(i=0; i<4; i++) Ncr[i] = de_s1_Ncr[i];
  for(i=0; i<4; i++) bcr[i] = de_s1_bcr[i];
  for(i=0; i<4; i++) xmaxcr[i] = de_s1_xmaxcr[i];
  for(i=0; i<13*4; i++) xMcr[i] = de_s1_xMcr[i];
  for(i=0; i<160; i++) s[i] = de_s1_s[i];
  for(i=0; i<40; i++) erp[i] = de_s1_erp[i];
  for(i=0; i<160; i++) wt[i] = de_s1_wt[i];
  drp[0] = de_s1_drp[0];
  lock[3]=1;
  SIGNAL(2);
  MARCUS_DEBUG_MESSAGE(-501) 
}


static void
allocate_shared_memory_variables(void) {
 int i;
 
 i=0;
 memory_map=(int *)shared_alloc(100*sizeof(int));

 en_r = (gsm)shared_alloc(sizeof(struct gsm_state));
 en_r->nrp = 40;
 memory_map[i] = en_r;
 i++;

 en_s1_S = (struct gsm_state *)shared_alloc(sizeof(struct gsm_state));
 memory_map[i] = en_s1_S;
 i++;
 en_s1_Nc = (word *)shared_alloc(4*sizeof(word));
 memory_map[i] = en_s1_Nc;
 i++;
 en_s1_bc = (word *)shared_alloc(4*sizeof(word));
 memory_map[i] = en_s1_bc;
 i++;
 en_s1_Mc = (word *)shared_alloc(4*sizeof(word));
 memory_map[i] = en_s1_Mc;
 i++;
 en_s1_xmaxc = (word *)shared_alloc(4*sizeof(word));
 memory_map[i] = en_s1_xmaxc;
 i++;
 en_s1_xMc = (word *)shared_alloc(13*4*sizeof(word));
 memory_map[i] = en_s1_xMc;
 i++;
 en_s1_LARc = (word *)shared_alloc(8*sizeof(word));
 memory_map[i] = en_s1_LARc;
 i++;
 en_s1_e = (word *)shared_alloc(50*sizeof(word));
 memory_map[i] = en_s1_e;
 i++;
 en_s1_so = (word *)shared_alloc(160*sizeof(word));
 memory_map[i] = en_s1_so;
 i++;
 
 
 //decoder allocation
 de_r = (gsm)shared_alloc(sizeof(struct gsm_state));
 de_r->nrp = 40;
 memory_map[i] = de_r;
 i++;
 MARCUS_DEBUG_MESSAGE(5500);
 MARCUS_DEBUG_MESSAGE(de_r);
 MARCUS_DEBUG_MESSAGE(5501);

 de_s1_S = (struct gsm_state *)shared_alloc(sizeof(struct gsm_state));
 memory_map[i] = de_s1_S;
 i++;
 de_s1_LARcr = (word *)shared_alloc(8*(sizeof(word)));
 memory_map[i] = de_s1_LARcr;
 i++;
 de_s1_Ncr = (word *)shared_alloc(4*(sizeof(word)));
 memory_map[i] = de_s1_Ncr;
 i++;
 de_s1_bcr = (word *)shared_alloc(4*(sizeof(word)));
 memory_map[i] = de_s1_bcr;
 i++;
 de_s1_Mcr = (word *)shared_alloc(4*(sizeof(word)));
 memory_map[i] = de_s1_Mcr; 
 i++;
 de_s1_xmaxcr = (word *)shared_alloc(4*(sizeof(word)));
 memory_map[i] = de_s1_xmaxcr;
 i++;
 de_s1_xMcr = (word *)shared_alloc(13*4*(sizeof(word)));
 memory_map[i] = de_s1_xMcr;
 i++;
 de_s1_s = (word *)shared_alloc(160*(sizeof(word)));
 memory_map[i] = de_s1_s;
 i++;
 de_s1_erp = (word *)shared_alloc(40*(sizeof(word)));
 memory_map[i] = de_s1_erp;
 i++;
 de_s1_wt = (word *)shared_alloc(160*(sizeof(word)));
 memory_map[i] = de_s1_wt;
 i++;
 de_s1_drp = (word *)shared_alloc((sizeof(word)));
 memory_map[i] = de_s1_drp;
 i++;
        
 items_memory_map=i;
}


static void
set_memory_map(void) {
 int i;
 i=0;
 //memory_map=(void *)(419435808);
 memory_map=(void *)(419434496);
 en_r = memory_map[i];
 i++;
 en_s1_S = memory_map[i];
 i++;
 en_s1_Nc = memory_map[i];
 i++;
 en_s1_bc = memory_map[i];
 i++;
 en_s1_Mc = memory_map[i];
 i++;
 en_s1_xmaxc = memory_map[i];
 i++;
 en_s1_xMc = memory_map[i];
 i++;
 en_s1_LARc = memory_map[i];
 i++;
 en_s1_e = memory_map[i];
 i++;
 en_s1_so = memory_map[i];
 i++; 
}


static void
dec_set_memory_map(void) {
 int i;
 i=10;
 //memory_map=(void *)(419435808); 
 memory_map=(void *)(419434496);
 de_r = memory_map[i];
 MARCUS_DEBUG_MESSAGE(5500);
 MARCUS_DEBUG_MESSAGE(de_r);
 MARCUS_DEBUG_MESSAGE(5501);
 i++; 
 de_s1_S = memory_map[i];
 i++;
 de_s1_LARcr = memory_map[i];
 i++;
 de_s1_Ncr = memory_map[i];
 i++;
 de_s1_bcr = memory_map[i];
 i++;
 de_s1_Mcr = memory_map[i]; 
 i++;
 de_s1_xmaxcr = memory_map[i];
 i++;
 de_s1_xMcr = memory_map[i];
 i++;
 de_s1_s = memory_map[i];
 i++;
 de_s1_erp = memory_map[i];
 i++;
 de_s1_wt = memory_map[i] ;
 i++;
 de_s1_drp = memory_map[i];
}


extern volatile int *lock;

static int
process_codec P0() {	
	gsm_signal    	en_s[ 160 ];
	gsm_frame	en_d;
#ifdef SASA_MPARM
	char *en_mparm_check; 
	int sasa_c;
	int sasa_i;
	static int en_iter_count=0;
	static int de_iter_count=0;
	int en_marcus_dummy;
#endif /*SASA_MPARM_CHECK*/
	int	      en_cc;
	word         *en_dp; //  = S->dp0 + 120;      /* [ -120...-1 ] */
	word         *en_dpp;// = dp;         /* [ 0...39 ]    */
	
	gsm_frame     de_s;
  	gsm_signal    de_d[ 160 ];
  	int           de_cc;
  	int           marcus_count = 0;
  	int           marcus_index = 0;
  	int           marcus_en_mem_entries = sizeof(ding_en_memory)/sizeof(char);
  	int           marcus_dummy;
  	int           marcus_out_dummy;
  	word          de_LARc[8], de_Nc[4], de_Mc[4];
  	word          de_bc[4], de_xmaxc[4], de_xmc[13*4];
  	int           de_j, de_k;
  	word          de_erp[40], de_wt[160];
  	word          *de_drp;// = S->dp0 + 120;


	if (get_id()==CPU_ENC) {	
	  lock[1]=1;
	  lock[5]=1;
	}
	if (get_id()==CPU_DEC) {
	  lock[7]=1;
	}
// 	if (!(en_r = gsm_create())) {
// 	      return -1;
// 	}
// 	(void)gsm_option(en_r, GSM_OPT_FAST,       &f_fast);
// 	(void)gsm_option(en_r, GSM_OPT_VERBOSE,    &f_verbose);
// 	(void)gsm_option(en_r, GSM_OPT_LTP_CUT,	&f_ltp_cut);


	if (get_id()==1) { 
	  allocate_shared_memory_variables();
	  (void)gsm_option(en_r, GSM_OPT_FAST,       &f_fast);
  	  (void)gsm_option(en_r, GSM_OPT_VERBOSE,    &f_verbose);
	  (void)gsm_option(en_r, GSM_OPT_LTP_CUT,    &f_ltp_cut);

	  MARCUS_DEBUG_MESSAGE(255);
	  MARCUS_DEBUG_MESSAGE(memory_map);
	  SIGNAL(5);
	  SIGNAL(7);
	}
	
	if (get_id()==CPU_ENC) {	  
	  MARCUS_DEBUG_MESSAGE(5);
	  WAIT(5);
	  MARCUS_DEBUG_MESSAGE(55);
	  set_memory_map();
	  MARCUS_DEBUG_MESSAGE(255);
	  MARCUS_DEBUG_MESSAGE(memory_map);	  	  
	}

	if (get_id()==CPU_DEC) {
	  MARCUS_DEBUG_MESSAGE(7);
	  WAIT(7);
	  MARCUS_DEBUG_MESSAGE(77);
	  dec_set_memory_map();
	  (void)gsm_option(de_r, GSM_OPT_FAST,    &f_fast);
  	  (void)gsm_option(de_r, GSM_OPT_VERBOSE, &f_verbose);
	  //de_drp = de_r->dp0 + 120;
	  MARCUS_DEBUG_MESSAGE(255);
	  MARCUS_DEBUG_MESSAGE(memory_map);	  	  
	}

//END OF MEMORY ALLOCATION ON BOTH PROCESSORS

	en_cc =1;
	de_cc = marcus_en_mem_entries;
        //START_MPARM_PROFILE(1);

	while ( (en_cc > 0) && (de_cc > 0) ){ /* encode and decode as long as input frames exist */
	  MARCUS_DEBUG_MESSAGE(0);	  
          if (get_id()==CPU_ENC) {
             en_iter_count++;
	     //lock[9]=1;
          }
	  if (get_id()==CPU_DEC) { 
	     de_iter_count++;
	     lock[9]=1;
          }
	 
	  if (get_id()==1) {
	     en_iter_count++;
	     de_iter_count++;
	     lock[4]=1;
	     lock[8]=1;
	  }
	
	  if ( (get_id()==1) && (en_iter_count==3) ) {
	     MARCUS_DEBUG_MESSAGE(90);
	     stop_metric();
	     stop_simulation();	
	     return 1;
	  }

 	  if ( (get_id()==CPU_ENC) && (en_iter_count==3) ) {
	     stop_metric();
	     stop_simulation();
	     return 1;
	  }

	  if ( (get_id()==CPU_DEC) && (de_iter_count==3) ) {
	     stop_metric();
	     stop_simulation();
	     return 1;
	  }
	  //BEGIN ENCODER
	  if (get_id()==1) en_cc = (*input)(en_s);
//	  if (en_cc <= 0) break;
	  
//	  if (en_cc < sizeof(s) / sizeof(*en_s))
//	    memset((char *)(en_s+en_cc), 0, sizeof(en_s)-(en_cc * sizeof(*en_s))); 

/*
	  //DEBUG input audio file
	  if (get_id() == 1)
	    for(marcus_dummy=0; marcus_dummy < 160; marcus_dummy++){	      
	       MARCUS_DEBUG_MESSAGE(s[marcus_dummy])
	   }
*/		
	  en_dp  = en_r->dp0 + 120;
    	  en_dpp = en_dp;
          //END: get input ready for encoder

	  de_drp = de_r->dp0 + 120;
	  
	  //START: get input ready for decoder
    	  if (marcus_index + sizeof(de_s) <= marcus_en_mem_entries)
      	     de_cc = sizeof(de_s);
    	  else
          de_cc = marcus_en_mem_entries - marcus_index;

          if ( (de_iter_count<3) && (get_id() == CPU_DEC_1) ) {
//	     MARCUS_DEBUG_MESSAGE(100);
             marcus_dummy = marcus_index + sizeof(de_s);
             marcus_count = 0;
	     //DEBUG input gsm frame
             for (marcus_index; marcus_index < marcus_dummy; marcus_index++) {
                de_s[marcus_count] = ding_en_memory[marcus_index];
		//MARCUS_DEBUG_MESSAGE(de_s[marcus_count]);
                marcus_count++;
             }
//	     MARCUS_DEBUG_MESSAGE(101);
          }	  
    	  //END: get input ready for decoder

	  // START: Encoder part 1
          if ( (en_iter_count<3) && (get_id()==1) )
            Gsm_Preprocess(en_r, en_s, en_s1_so);

          if ( (en_iter_count<3) && (get_id()==1) )
            Gsm_LPC_Analysis(en_r, en_s1_so, en_s1_LARc);

    	  if ( (en_iter_count<3) && (get_id()==1) )
      	    Gsm_Short_Term_Analysis_Filter(en_r, en_s1_LARc, en_s1_so);

          if ( (en_iter_count<3) && (get_id()==1) ) {
	     MARCUS_DEBUG_MESSAGE(333);
             store_from_locals(en_s1_S, en_s1_Nc, en_s1_bc, en_s1_Mc, en_s1_xmaxc, 
			       en_s1_xMc, en_s1_LARc, en_s1_e, en_s1_so);	  
          }
          // END: Encoder part 1

	  //DECODER
	  if ( (de_iter_count<3) && (get_id()==CPU_DEC_1) )
             gsm_decode_marcus(de_LARc, de_Nc, de_Mc, de_bc, de_xmaxc, de_xmc, de_s);

          if ( (de_iter_count<3) && (get_id()== CPU_DEC_1) ) {
             MARCUS_DEBUG_MESSAGE(-700)
             word *xmaxcr = de_xmaxc;
      	     word *bcr    = de_bc;
             word *Ncr    = de_Nc;
             word *Mcr    = de_Mc;
             word *xMcr   = de_xmc;
	     
             for (de_j=0; de_j <= 3; de_j++, xmaxcr++, bcr++, Ncr++, Mcr++, xMcr += 13) {		 
                 Gsm_RPE_Decoding(de_r, *xmaxcr, *Mcr, xMcr, de_erp );
		 Gsm_Long_Term_Synthesis_Filtering(de_r, *Ncr, *bcr, de_erp, de_drp );		 
                 for (de_k = 0; de_k <= 39; de_k++) de_wt[ de_j * 40 + de_k ] =  de_drp[de_k];
             }
	     dec_store_from_locals(de_r, de_LARc, de_Nc, de_bc, de_Mc, de_xmaxc, 
	                           de_xmc, de_d, de_erp, de_wt, de_drp);
	     SIGNAL(9);
	     MARCUS_DEBUG_MESSAGE(7005);
	  }

	  if (get_id()==CPU_DEC) {
	     MARCUS_DEBUG_MESSAGE(7006);	     
	     WAIT(9);
	     MARCUS_DEBUG_MESSAGE(7007);
	     dec_read_to_locals(de_r, de_LARc, de_Nc, de_bc, de_Mc, de_xmaxc,
                                de_xmc, de_d, de_erp, de_wt, de_drp);
	     Gsm_Short_Term_Synthesis_Filter( de_r, de_LARc, de_wt, de_d );
             Postprocessing(de_r, de_d);
             MARCUS_DEBUG_MESSAGE(-10500)
             for (de_k=0; de_k<160; de_k++)
                MARCUS_DEBUG_MESSAGE(de_d[de_k])
             MARCUS_DEBUG_MESSAGE(-10501)
		
             MARCUS_DEBUG_MESSAGE(8);
	     SIGNAL(8);
	  }
	  //END DECODER

   	  if ( (en_iter_count<3) && (get_id()==1) ) {
		//on CPU1 we wait for CPU2 and CPU3 to finish		
		//lock[4]=1;
	     MARCUS_DEBUG_MESSAGE(4);		
	     WAIT(4);
	     MARCUS_DEBUG_MESSAGE(44);
	     //lock[8]=1;
	     WAIT(8);
	     MARCUS_DEBUG_MESSAGE(88);   
          }
		
	  //START: Encoder part 2
    	  if (get_id()==CPU_ENC) {	      
      	     read_to_locals(en_s1_S, en_s1_Nc, en_s1_bc, en_s1_Mc, 
			     en_s1_xmaxc, en_s1_xMc, en_s1_LARc, en_s1_e, en_s1_so);	      
	  }

    	  if (get_id()==CPU_ENC) {
             word * loc_xmc = en_s1_xMc;
      	     word * loc_Nc = en_s1_Nc;
             word * loc_bc = en_s1_bc;
             word * loc_xmaxc = en_s1_xmaxc;
             word * loc_Mc = en_s1_Mc;
	     int k;		      
	     for (k = 0; k <= 3; k++, loc_xmc += 13) {
        	Gsm_Long_Term_Predictor(    en_r,
                                    en_s1_so+k*40,  /* d      [0..39] IN */
                                    en_dp,        /* dp  [-120..-1] IN  */
                                    en_s1_e + 5,     /* e      [0..39] OUT */
                                    en_dpp,       /* dpp    [0..39] OUT */
                                    loc_Nc++,
                                    loc_bc++);

        	Gsm_RPE_Encoding        ( en_r,
                                  en_s1_e + 5,     /* e      ][0..39][ IN/OUT */
                                  loc_xmaxc++, loc_Mc++, loc_xmc );
        	{
          	register int i;
          	register longword ltmp;
          	for (i = 0; i <= 39; i++)
            		en_dp[ i ] = GSM_ADD( en_s1_e[5 + i], en_dpp[i] );
        	}
        	en_dp  += 40;
        	en_dpp += 40;
      	      }
           }

	   if( get_id()==CPU_ENC)
              (void)memcpy( (char *)en_r->dp0, (char *)(en_r->dp0 + 160),
                    120 * sizeof(*en_r->dp0) );

           if (get_id()==CPU_ENC)
      	      gsm_encode_marcus(en_s1_LARc, en_s1_Nc, en_s1_Mc, 
		       	        en_s1_bc, en_s1_xmaxc, en_s1_xMc, en_d);


#ifdef SASA_MPARM
	  if (get_id()==CPU_ENC) {
	    en_mparm_check = (char *)en_d;
	    MARCUS_DEBUG_MESSAGE(25000)
	    for (sasa_i=0;sasa_i<sizeof(en_d);sasa_i++) {
	      sasa_c = en_mparm_check[sasa_i]; 
	      PR(get_id(),5, sasa_c);
	    }  
	    // release memory only after print-out is finished
	    MARCUS_DEBUG_MESSAGE(25001)	  
	    SIGNAL(4);
	  }	  
	  
#endif /*SASA_MPARM_CHECK*/
	}
	
	if (en_cc < 0) {
	  perror(inname ? inname : "stdin");
	  gsm_destroy(en_r);
	  return -1;
	}
	gsm_destroy(en_r);
	return 0;
}

static int process_encode P0()
{ 
        
	return 0;
}


static int process_decode P0()
{
        
	return 0;
}

static int process P1((name), char * name)
{
	int step = 0;

	out     = (FILE *)0;
	in      = (FILE *)0;

	outname = (char *)0;
	inname  = (char *)0;
	//PR(0,2,-6);
	if (!open_input(name, &instat) || !open_output(name))
		goto err;
	//PR(0,2,-7);		
	if ((*(f_decode ? init_output    : init_input))()) {
		fprintf(stderr, "%s: error %s %s\n",
			progname,
			f_decode ? "writing header to" : "reading header from",
			f_decode ? (outname ? outname : "stdout")
				 : (inname ? inname : "stdin"));
		goto err;
	}
	//PR(0,2,-8);

	process_codec();

//	if ((*(f_decode ? process_decode : process_encode))())
//		goto err;

	//PR(0,2,-9);
#ifndef SASA_COMMENT	
	if (fflush(out) < 0 || ferror(out)) {
		perror(outname ? outname : "stdout");
		fprintf(stderr, "%s: error writing \"%s\"\n", progname,
				outname ? outname:"stdout");
		goto err;
	}

	if (out != stdout) {
		printf("\nsasa77\n"); fflush(stdout);
		update_times();
		update_mode ();
		update_own  ();

		if (fclose(out) < 0) {
			perror(outname);
			fprintf(stderr, "%s: error writing \"%s\"\n",
				progname, outname);
			goto err;
		}
		if (outname != name) free(outname);
		outname = (char *)0;
	}
	out = (FILE *)0;
#endif /*SASA_COMMENT*/	
	if (in  != stdin) {
#ifndef SASA_COMMENT
		(void)fclose(in), in = (FILE *)0;
#endif
		if (!f_cat && !f_precious) {
#ifndef SASA
			if (unlink(inname) < 0) {
				perror(inname);
				fprintf(stderr,
					"%s: source \"%s\" not deleted.\n",
					progname, inname);
			}
#endif
			goto err;
		}
		if (inname != name) free(inname);
		inname = (char *)0;
	}
	return 0;

	/*
	 *  Error handling and cleanup.
	 */
err:
	if (out && out != stdout) {
		(void)fclose(out), out = (FILE *)0;
#ifndef SASA
		if (unlink(outname) < 0 && errno != ENOENT && errno != EINTR) {
			perror(outname);
			fprintf(stderr, "%s: could not unlink \"%s\"\n",
				progname, outname);
		}
#endif
	}
	if (in && in != stdin) (void)fclose(in), in = (FILE *)0;

	if (inname  && inname  != name) free(inname);
	if (outname && outname != name) free(outname);
	//PR(0,2,-10);
	return -1;
}

static void version P0()
{
	printf( "%s 1.0, version %s\n",
		progname,
		"$Id: toast.c,v 1.8 1996/07/02 10:41:04 jutta Exp $" );
}

static void help P0()
{
#ifndef SASA_COMMENT
	printf("Usage: %s [-fcpdhvaulsFC] [files...]\n", progname);
	printf("\n");

	printf(" -f  force     Replace existing files without asking\n");
	printf(" -c  cat       Write to stdout, do not remove source files\n");
	printf(" -d  decode    Decode data (default is encode)\n");
	printf(" -p  precious  Do not delete the source\n");
	printf("\n");

	printf(" -u  u-law     Force 8 kHz/8 bit u-law in/output format\n");
	printf(" -s  sun .au   Force Sun .au u-law in/output format\n");
	printf(" -a  A-law     Force 8 kHz/8 bit A-law in/output format\n");
	printf(" -l  linear    Force 16 bit linear in/output format\n");
	printf("\n");

	printf(" -F  fast      Sacrifice conformance to performance\n");
	printf(" -C  cutoff    Ignore most samples during LTP\n");
	printf(" -v  version   Show version information\n");
	printf(" -h  help      Print this text\n");
	printf("\n");
#endif
}


static void set_format P1((f), struct fmtdesc * f)
{
	if (f_format && f_format != f) {
		fprintf( stderr,
	"%s: only one of -[uals] is possible (%s -h for help)\n",
			progname, progname);
		exit(1);
	}

	f_format = f;
}

struct gsm_state;
#ifdef SASA_MPARM
int main1 P2((ac, av), int ac, char **av)
#else
int main P2((ac, av), int ac, char **av)
#endif
{
	int  		opt;
	int i;
	extern int	optind;
	extern char	* optarg;
#ifdef SASA_MPARM
	start_metric();
#endif
	parse_argv0(*av);
#ifdef SASA_MPARM
	
#endif

#ifndef SASA_COMMENT
	while ((opt = getopt(ac, av, "fcdpvhuaslVFC:")) != EOF) switch (opt) {

	case 'd': f_decode   = 1; break;
	case 'f': f_force    = 1; break;
	case 'c': f_cat      = 1; break;
	case 'p': f_precious = 1; break;
	case 'F': f_fast     = 1; break;
	case 'C': f_ltp_cut  = 100; break;
#ifndef	NDEBUG
	case 'V': f_verbose  = 1; break;
#endif

	case 'u': set_format( &f_ulaw   ); break;
	case 'l': set_format( &f_linear ); break;
	case 'a': set_format( &f_alaw	); break;
	case 's': set_format( &f_audio  ); break;

	case 'v': version(); exit(0);
	case 'h': help();    exit(0);

	default: 
	usage:
#ifdef SASA_MPARM
	//	PR(0,2,-3);		
#endif
		fprintf(stderr,
	"Usage: %s [-fcpdhvuaslFC] [files...] (-h for help)\n",
			progname);
		exit(1);
	}

	f_precious |= f_cat;

	av += optind;
	ac -= optind;

	catch_signals(onintr);
#endif /*SASA*/
	//PR(0,2,-4);
#ifndef SASA_COMMENT
	if (ac <= 0) process( (char *)0 );
	else while (ac--) process( *av++ );
#else
		
	process("ding.au");
	
	//process_codec();

#endif/*SASA_COMMENT*/
}
